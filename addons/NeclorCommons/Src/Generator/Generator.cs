using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Reflection;
using System.Security.Claims;
using System.Text;


namespace Neclor.Commons.Generator;





[Generator]
public class InterfaceGenerator : ISourceGenerator {

	public void Initialize(GeneratorInitializationContext context) { }

	public void Execute(GeneratorExecutionContext context) {

		foreach (var partialClass in GetPartialClasses(context)) {
			ClassDeclarationSyntax classSyntax = partialClass.Syntax;
			INamedTypeSymbol classSymbol = partialClass.Symbol;

			List<(INamedTypeSymbol, IMethodSymbol)> methods = GetMissingInterfaceMethods(classSymbol);
			if (methods.Count == 0) continue;

			var 


		}
	}









	static List<(ClassDeclarationSyntax Syntax, INamedTypeSymbol Symbol)> GetClasses(GeneratorExecutionContext context) {
		List<(ClassDeclarationSyntax, INamedTypeSymbol)> classes = [];

		foreach (SyntaxTree tree in context.Compilation.SyntaxTrees) {
			SemanticModel model = context.Compilation.GetSemanticModel(tree);
			SyntaxNode root = tree.GetRoot();

			List<ClassDeclarationSyntax> classSyntaxes = [.. root.DescendantNodes().OfType<ClassDeclarationSyntax>()];

			foreach (ClassDeclarationSyntax syntax in classSyntaxes) {
				INamedTypeSymbol? symbol = model.GetDeclaredSymbol(syntax);
				if (symbol is null) continue;

				classes.Add((syntax, symbol));
			}
		}
		return classes;
	}

	static List<(ClassDeclarationSyntax Syntax, INamedTypeSymbol Symbol)> GetPartialClasses(GeneratorExecutionContext context) {
		return [.. GetClasses(context).Where(c => c.Syntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))];
	}

	static List<(INamedTypeSymbol Interface, IMethodSymbol Method)> GetMissingInterfaceMethods(INamedTypeSymbol classSymbol) {
		List<(INamedTypeSymbol, IMethodSymbol)> methods = [];

		foreach (INamedTypeSymbol interfaceSymbol in classSymbol.AllInterfaces) {

			List<IMethodSymbol> methodSymbols = [.. interfaceSymbol.GetMembers().OfType<IMethodSymbol>()];

			foreach (IMethodSymbol methodSymbol in methodSymbols) {
				if (classSymbol.FindImplementationForInterfaceMember(methodSymbol) is not null) continue;

				methods.Add((interfaceSymbol, methodSymbol));
			}
		}
		return methods;
	}

	static string GenerateClassCode(ClassDeclarationSyntax classSyntax, INamedTypeSymbol classSymbol, List<(INamedTypeSymbol Interface, IMethodSymbol Method)> methods) {
		StringBuilder stringBuilder = new();

		stringBuilder.AppendLine("// <auto-generated />\n\n");

		stringBuilder.AppendLine($"namespace {classSymbol.ContainingNamespace};\n\n");


		string modifiers = string.Join(" ", classSyntax.Modifiers.Select((SyntaxToken m) => m.Text));

		stringBuilder.AppendLine($"{modifiers} class {classSymbol.Name} {{");

		foreach (var method in methods) {
			stringBuilder.AppendLine(GenerateMethodCode(method.Interface, method.Method));
		}

		stringBuilder.AppendLine("}");
		stringBuilder.AppendLine("");
		return stringBuilder.ToString();
	}

	static string GenerateMethodCode(INamedTypeSymbol interfaceSymbol, IMethodSymbol methodSymbol) {
		StringBuilder stringBuilder = new();

		string returnType = methodSymbol.ReturnType.ToDisplayString();








		var parameters = "";
		var args = "";

		for (int i = 0; i < method.Parameters.Length; i++) {
			var p = method.Parameters[i];
			parameters += p.Type.ToDisplayString() + " " + p.Name;
			args += p.Name;
			if (i < method.Parameters.Length - 1) {
				parameters += ", ";
				args += ", ";
			}
		}

		var call = $"(({iface.ToDisplayString()})this).{method.Name}({args})";

		if (ret == "void")
			return $"    public void {method.Name}({parameters}) => {call};";
		else
			return $"    public {ret} {method.Name}({parameters}) => {call};";
	}
}








	/*
	IEnumerable<ClassDeclarationSyntax> GetClasses(GeneratorExecutionContext context) {
		return context.Compilation.SyntaxTrees.SelectMany(st => st.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>());
	}

	IEnumerable<ClassDeclarationSyntax> GetPartialClasses(GeneratorExecutionContext context) {
		return GetClasses(context).Where(cds => cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)));
	}


	IEnumerable<>

	*/



}
